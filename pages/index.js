import Head from 'next/head';
import React from "react";
import { useEffect, useRef, useState } from "react";
import _ from "lodash";

// import glReset from "gl-reset";
import Drawer from '@material-ui/core/Drawer';

import { Initialise } from "../webgl/procedural-terrain"
import styles from '../styles/Home.module.css'
import { Container, Button, IconButton, Typography, Slider, TextField, Switch } from '@material-ui/core';
import { Menu, ChevronLeft, ChevronRight } from '@material-ui/icons';

const paramInputs = [
  {
    name: "size",
    group: 'generation',
    type: "slider",
    props: {
      min: 10,
      max: 40,
      step: 1,
      marks: true,
    }
  },
  {
    name: "octaves",
    group: 'perlin',
    type: "slider",
    props: {
      min: 1,
      max: 5,
      step: 1,
      marks: true,
    }
  },
  {
    name: "lacunarity",
    group: 'perlin',
    type: "slider",
    props: {
      min: 0.0,
      max: 1.0,
      step: 0.05,
      marks: false,
    }
  },
  {
    name: "n",
    group: 'perlin',
    type: "slider",
    props: {
      min: 1,
      max: 20,
      step: 1,
      marks: true,
    }
  },
  {
    name: "seed",
    group: 'perlin',
    type: "textfield",
    props: {
      defaultValue: "",
    }
  },
  {
    name: "normalizeGrad",
    group: 'perlin',
    type: "switch",
    props: {
      defaultChecked: true,
    }
  },
]


export default function Home() {
  // scene-related hooks
  const canvasRef = useRef();
  const scene = useRef({
    controls: {
      startLoop: () => { },
      stopLoop: () => { }
    }
  });

  const [sceneParams, setSceneParams] = useState({
    generation: {
      size: 20
    },
    perlin: {
      octaves: 2,
      lacunarity: 2,
      persistence: 0.1,
      n: 3,
      seed: '',
      normalizeGrad: true,
    },
    terrain: {
      WATER: -0.3,
      SAND: -0.1,
      GRASS: 0.2,
      MOUNTAIN: 1
    },
    water: {
      maxVertexOscillation: 0.05
    }
  });


  function createOnParamChange(item) {    
    return (event, value)=>{
      let newValue = item.type == 'slider' ? value : event.target.value;

      setSceneParams({...sceneParams, [item.group]: {...sceneParams[item.group], [item.name]: newValue}});
    };
  }


  // hooks for metrics reporting
  const [metrics, setSceneMetrics] = useState({
    fps: 0,
  });

  // report fps based on average of the last 10 frames
  let prevTime = performance.now();
  let frameCounter = 0;
  // callback passed to loop, call on each loop to get the frame rate
  const reportTimeCallback = (currentFrameTime) => {
    if (frameCounter < 5) {
      frameCounter++;
      return;
    }

    const deltaFrameTime = currentFrameTime - prevTime;
    const fps = Math.round(5 * (1000 / deltaFrameTime));

    setSceneMetrics({
      ...metrics,
      fps,
    });

    prevTime = currentFrameTime;
    frameCounter = 0;
  }

  // on component mount
  useEffect(() => {

  }, [])

  // on sceneParams change (will be called once on mount)
  useEffect(() => {
    // reset gl context
    const gl = canvasRef.current.getContext('webgl2');
    // glReset(gl);

    // re-initialize, set new scene controls and start scene
    scene.current.controls.stopLoop(); //kill old loop
    scene.current.controls = Initialise(gl, canvasRef.current, sceneParams, reportTimeCallback);
    scene.current.controls.startLoop();
  }, [sceneParams]);

  // ui-related hooks
  const [drawerOpen, setDrawerOpen] = useState(false);
  const handleDrawerOpen = () => { setDrawerOpen(true) };
  const handleDrawerClose = () => { setDrawerOpen(false) };

  const drawerItems = paramInputs.map((item) => {
    if (item.type == "slider") {
      return (
        <React.Fragment>
          <Typography>{item.name}</Typography>
          <Slider {...item.props} value={sceneParams[item.group][item.name]} onChange={createOnParamChange(item)} />
        </React.Fragment>
      )
    }

    if (item.type == "textfield") {
      return (
        <React.Fragment>
          <Typography>{item.name}</Typography>
          <TextField {...item.props} value={sceneParams[item.group][item.name]} onChange={createOnParamChange(item)}/>
        </React.Fragment>
      )
    }

    if (item.type == "switch") {
      return (
        <React.Fragment>
          <Typography>{item.name}</Typography>
          <Switch {...item.props} value={sceneParams[item.group][item.name]} onChange={createOnParamChange(item)}/>
        </React.Fragment>
      )
    }

  })

  return (
    <div className={styles.container}>
      <Head>
        <title>Procedural Terrain Generation</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>

      <main className={styles.main}>
        <Container disableGutters={true} maxWidth={false}>
          <Drawer
            variant="persistent"
            anchor="left"
            open={drawerOpen}
          >
            <Container style={{ width: "300px" }}>
              <IconButton onClick={handleDrawerClose}>
                <ChevronLeft />
              </IconButton>

              {drawerItems}
            </Container>
          </Drawer>


          <IconButton
            style={{ position: "absolute", top: "0.5rem", left: "0.5rem", zIndex: 10 }}
            onClick={handleDrawerOpen}
          >
            <Menu />
          </IconButton>
          <a style={{ position: "absolute", top: "0.5rem", right: "0.5rem", zIndex: 10 }}>FPS: {metrics.fps}</a>
          <canvas width="720" height="480" ref={canvasRef}></canvas>
        </Container>

      </main>
    </div>
  )
}
